## 들어가기 전에

- 애스펙트 지향 프로그래밍?

  - 코드 중복을 줄이려고 모듈화를 시켰는데 모듈들이 사용하는 중복 코드들이 또 생겨서 그걸 분리하려고... (

    횡단 관심사

    라고 함) 

    - 로그, 트랜잭션, 보안, 캐싱 등등
    - Sub Task가 한 모듈로 응집되어 응집력이 높아짐

- 그런데 MSA로 넘어가면서 인증 **서비스**, 로그는 로그스태시같은 걸로 수집, 캐싱은 레디스 클러스터에... 이런 식으로 바뀌고 있는... 느낌? 아닌가?ㅎㅎ;

## 2-13

- 스프링에서 AOP 구현은 프록시로 구현
  - @EnableAspectJAutoProxy
- Aspect
  - 어디서 (포인트컷) + 무엇을(어드바이스)
- 조인포인트
  - 포인트컷으로 매치한 실행 지점
- 어드바이스 어노테이션
  - @Before 
    - 특정 프로그램 실행 이전 실행
  - @After 
    - 조인포인트 끝나면 실행
    - 조인포인트 실행 성공 여부와 상관없이 동작
  - @AfterReturning 
    - 조인포인트가 성공해서 값을 반환했을 때만 동작
  - @AfterThrowing 
    - 조인포인트가 예외를 던졌을 때만 동작
  - @Around 
    - 조인포인트를 완전히 장악해서 언제 실행할 지, 실행을 할 지 말 지, 계속 실행할 지 여부도 정할 수 있음 
      - 하지만 C에서도 볼 수 있듯 개발자에게 맡겨버리는 건 보통 망하기 쉽기 때문에 그냥 위에 4개로 해결하자...ㅎㅎ...

## 2-14

- 어드바이스의 시그니처에 JoinPoint형 인수를 선언하면 조인포인트 정보를 얻을 수 있음 
  - getTarget() : 대상객체 반환
  - getThis() : 프록시 객체 반환

## 2-15

- 애스펙트 간 우선순위는 Ordered 인터페이스를 구현 혹은 @Order 어노테이션을 붙여서 지정

## 2-16

- @Pointcut을 이용하면 포인트컷만 따로 정의해 여러 어드바이스에서 재사용할 수 있음